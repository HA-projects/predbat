# ------------------------------------------------------------------
# Victron Energy Multiplus Modbus Config
# based on Sofar template
# ------------------------------------------------------------------
---
pred_bat:
  module: predbat
  class: PredBat

  # Sets the prefix for all created entities in HA - only change if you want to run more than once instance
  prefix: predbat

  # Timezone to work in
  timezone: Europe/Paris

  # XXX: Template configuration, delete this line once you have set up for your system
#   template: True

  # If you are using Predbat outside of HA then set the HA URL and Key (long lived access token here)
  #ha_url: 'http://homeassistant.local:8123'
  #ha_key: 'xxx'

  # Currency, symbol for main currency second symbol for 1/100s e.g. $ c or £ p or e c
  currency_symbols:
   - '€'
   - 'c'

  # Number of threads to use in plan calculation
  # Can be auto for automatic, 0 for off or values 1-N for a fixed number
  threads: auto

  #
  # Sensors, more than one can be specified and they will be summed up automatically
  #
  # For two inverters the load today would normally be the master load sensor only (to cover the entire house)
  # If you have three phase and one inverter per phase then you would need three load sensors
  #
  # For pv_today if you have multiple solar inverter inputs then you should include one entry for each inverter
  #
  load_today:
    - sensor.multiplus_total_energy_today
  import_today:
    - sensor.multiplus_energy_from_grid_today
  export_today:
    - sensor.multiplus_energy_to_grid_today
  pv_today:
    - sensor.solar_yield_today

  # Load forecast can be used to add to the historical load data (heat-pump)
  # To link to Predheat
  # Data must be in the format of 'last_updated' timestamp and 'energy' for incrementing kWh
  #load_forecast:
  #  - predheat.heat_energy$external
  #
  #  Unused Sensors
  #      sensor.multiplus_energy_from_battery
  #      sensor.multiplus_energy_to_battery
  #


 #### Inverter specific #####
  num_inverters: 1
  inverter_type: "SF" # needs to be "Victron"
  #
  # Run balance inverters every N seconds (0=disabled) - only for multi-inverter
  balance_inverters_seconds: 0


  #### Power and Inverter sensors #####
  battery_power:
    - sensor.multiplus_battery_power
  pv_power:
    - sensor.multiplus_solar_power
  load_power:
    - sensor.ac_consumption_l1
  soc_percent:  # or   soc_kw:  in kWh
    - sensor.battery_state_of_charge

  # Battery capacity in kWh put in a number for this value
  soc_max:
    - 9.6
  charge_limit:
   - 100
  reserve:
    - 20
  scheduled_charge_enable:
   - off
  scheduled_discharge_enable:
   - off
  charge_start_time:
   - off
  charge_end_time:
   - off
  discharge_start_time:
   - off
  discharge_end_time:
   - off

  # Inverter max AC limit (one per inverter). E.g for a 3.6kw inverter set to 3600
  # If you have a second inverter for PV only please add the two values together
  inverter_limit:
   - 5000

  # Set the maximum charge/discharge rate of the battery
  battery_rate_max:
   - 4000

  # Export limit is a software limit set on your inverter that prevents exporting above a given level
  # When enabled Predbat will model this limit
  #export_limit:
  # - 3600
  # - 3600

  # Some inverters don't turn off when the rate is set to 0, still charge or discharge at around 200w
  # The value can be set here in watts to model this (doesn't change operation)
  #inverter_battery_rate_min:
  #  - 200

  # Workaround to limit the maximum reserve setting, some inverters won't allow 100% to be set
  # inverter_reserve_max : 99

  # Some batteries tail off their charge rate at high soc%
  # enter the charging curve here as a % of the max charge rate for each soc percentage.
  # the default is 1.0 (full power)
  # The example below is from GE 9.5kwh battery with latest firmware and gen1 inverter
  #battery_charge_power_curve:
  #  91 : 0.91
  #  92 : 0.81
  #  93 : 0.71
  #  94 : 0.62
  #  95 : 0.52
  #  96 : 0.43
  #  97 : 0.33
  #  98 : 0.24
  #  99 : 0.24
  #  100 : 0.24

  # Inverter clock skew in minutes, e.g. 1 means it's 1 minute fast and -1 is 1 minute slow
  # Separate start and end options are applied to the start and end time windows, mostly as you want to start late (not early) and finish early (not late)
  # Separate discharge skew for discharge windows only
  inverter_clock_skew_start: 0
  inverter_clock_skew_end: 0
  inverter_clock_skew_discharge_start: 0
  inverter_clock_skew_discharge_end: 0

  # Clock skew adjusts the Appdaemon time
  # This is the time that Predbat takes actions like starting discharge/charging
  # Only use this for workarounds if your inverter time is correct but Predbat is somehow wrong (AppDaemon issue)
  # 1 means add 1 minute to AppDaemon time, -1 takes it away
  clock_skew: 0

  # Solcast cloud interface, set this or the local interface below
  #solcast_host: 'https://api.solcast.com.au/'
  #solcast_api_key: 'xxxx'
  #solcast_poll_hours: 8

  # Set these to match solcast sensor names if not using the cloud interface
  # The regular expression (re:) makes the solcast bit optional
  # If these don't match find your own names in Home Assistant
  # Set these to match solcast sensor names if not using the cloud interface
  # The regular expression (re:) makes the solcast bit optional
  # If these don't match find your own names in Home Assistant
  pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today)
  pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow)
  pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3))
  pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))


  # Or set your actual rates across time for import and export
  # If start/end is missing it's assumed to be a fixed rate
  # Gaps are filled with zero rate
  rates_import:
    -  start: "21:00:00"
       end: "06:30:00"
       rate: input_number.electric_tariff_price_low
    -  start: "06:30:00"
       end: "21:00:00"
       rate: input_number.electric_tariff_price_high

  rates_export:
    -  rate: 0


  # For pv estimate, leave blank for central estimate, or add 10 for 10% curve (worst case) or 90 or 90% curve (best case)
  # If you use 10 then disable pv_metric10_weight below
  # pv_estimate: 10

  # Days previous is the number of days back to find historical load data
  # Recommended is 7 to capture day of the week but 1 can also be used
  # if you have more history you could use 7 and 14 (in a list) but the standard data in HA only lasts 10 days
  days_previous:
    - 7
    - 14

  # Days previous weight can be used to control the weighting of the previous load points, the values are multiplied by their
  # weights and then divided through by the total weight. E.g. if you used 1 and 0.5 then the first value would have 2/3rd of the weight and the second 1/3rd
  # Include one value for each days_previous value, each weighting on a separate line.
  # If any days_previous's that are not given a weighting they will assume a default weighting of 1.
  days_previous_weight:
    - 1
    - 0.5

  # Number of hours forward to forecast, best left as-is unless you have specific reason
  forecast_hours: 48

  # Specify the devices that notifies are sent to, the default is 'notify' which goes to all
  notify_devices:
    - mobile_app_your_device_id

  # Battery scaling makes the battery smaller (e.g. 0.9) or bigger than its reported
  # If you have an 80% DoD battery that falsely reports it's kwh then set it to 0.8 to report the real figures
  battery_scaling: 1.0

  # Can be used to scale import and export data, used for workarounds
  import_export_scaling: 1.0

# Export triggers:
  # For each trigger give a name, the minutes of export needed and the energy required in that time
  # Multiple triggers can be set at once so in total you could use too much energy if all run
  # Creates an entity called 'binary_sensor.predbat_export_trigger_<name>' which will be turned On when the condition is valid
  # connect this to your automation to start whatever you want to trigger
    #   export_triggers:
    #      - name: 'large'
    #       minutes: 60
    #       energy: 1.0
    #      - name: 'small'
    #       minutes: 15
    #       energy: 0.25

  # If you have a sensor that gives the energy consumed by your solar diverter then add it here
  # this will make the predictions more accurate. It should be an incrementing sensor, it can reset at midnight or not
  # It's assumed to be in Kwh but scaling can be applied if need be
  #iboost_energy_today: 'sensor.tasmota_energy_today'
  #iboost_energy_scaling: 1.0


##### Car charging settings   #######
  # car_charging_energy defines an incrementing sensor which measures the charge added to your car
  # is used for car_charging_hold feature to filter out car charging from the previous load data
  # Automatically set to detect Wallbox and Zappi, if it doesn't match manually enter your sensor name
  # Also adjust car_charging_energy_scale if it's not in kwH to fix the units
  car_charging_energy:
    - sensor.shelly_em_channel_1_energy
    - sensor.shelly_em_channel_2_energy
  # Additional consumers to remove other house load kWh from the data Predbat uses for the forecast, here Heat Pump.

# Defines the number of cars modelled by the system, set to 0 for no car
  num_cars: 1

# car_charging_soc
  # You should configure this to point to a sensor (on the HA integration for your EV charger) that specifies the car's current charge level expressed as a percentage
  # it must NOT be set to a sensor that gives the car's current kWh value as this will cause Predbat to charge the car to an incorrect level.
  # If you don't specify a sensor, Predbat will default to 0%.
  car_charging_soc:
    - input_number.ev_battery_estimated_soc

# car_charging_planned is set to a sensor which when positive indicates the car will charged in the upcoming low rate slots
  # This should not be needed if you use Intelligent Octopus slots which will take priority if enabled
  # The list of possible values is in car_charging_planned_response
  # Auto matches Zappi and Wallbox, or change it for your own
  # One entry per car
  # car_charging_planned:
  car_charging_planned: input_select.ev_charging_planned_for_predbat

# car_charging_planned_response #
 # An array of values for the above car_charging_planned sensor which indicate that the car is plugged in and will charge in the next low rate slot.
 # The template apps.yaml comes with a set of pre-defined sensor values that should match most EV chargers.
 # Customise for your car charger sensor if it sets sensor values that are not in the list.
  car_charging_planned_response:
      - 'off'
      - 'enabled'
      - 'plugged in'
      - 'connected'
      - 'charging'
 #    - 'yes'
 #    - 'on'
 #    - 'true'
 #    - 'ev connected'
 #    - 'paused'
 #    - 'waiting for car demand'
 #    - 'waiting for ev'
 #     - 'scheduled'
 #    - 'latched'
 #    - 'locked'

  # In some cases car planning is difficult (e.g. Ohme with Intelligent doesn't report slots)
  # The car charging now can be set to a sensor to indicate the car is charging and to plan
  # for it to charge during this 30 minute slot
  car_charging_now:
    - binary_sensor.ev_charging_onoff

  # Positive responses for car_charging_now
  #  car_charging_now_response:
 #    - 'yes'
  #    - 'on'
 #    - 'true'

# car_charging_battery_size #
  # Set this value in apps.yaml to the car's battery size in kWh. If not set,
  # Predbat defaults to 100kWh. It will be used to predict when to stop car charging.
  car_charging_battery_size:
   - input_number.ev_battery_size

# car_charging_limit #
  # You should configure this to point to a sensor that specifies the % limit the car is set to charge to. This could be a sensor on the EV charger integration or a Home Assistant helper entity you can set as you wish. If you don't specify a sensor Predbat will default to 100% - i.e. fill the car to full.

